generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// UI Language for application interface ONLY
model UILanguage {
  id           Int           @id @default(autoincrement())
  name         String        @unique // "English", "Spanish"
  code         String        @unique // "en", "es"
  icon         String?
  is_supported Boolean       @default(false)
  userProfiles UserProfile[]

  @@map("ui_languages")
}

model UserProfile {
  id     Int     @id @default(autoincrement())
  userId String  @db.Uuid
  name   String?
  phone  String?

  // UI language preference (separate from translation languages)
  uiLanguageId Int?
  uiLanguage   UILanguage? @relation(fields: [uiLanguageId], references: [id])

  onboardingCompleted Boolean @default(false)

  // Communities user joined (for LRL contributions)
  targetLanguages     UserTargetLanguage[]
  votes               Vote[]
  requests            TranslationRequest[] @relation("RequestedBy")
  approvals           TranslationRequest[] @relation("ApprovedBy")
  ratings             NeoRating[]          @relation("RatedBy")
  neos                Neo[]
  quizAttempts    QuizAttempt[]
  
  @@unique([userId])
  @@map("user_profile")
}

model Role {
  id    Int        @id @default(autoincrement())
  name  String     @unique
  users UserRole[]

  @@map("roles")
}

model UserRole {
  id     Int    @id @default(autoincrement())
  userId String @db.Uuid
  roleId Int

  role Role @relation(fields: [roleId], references: [id])

  @@unique([userId, roleId])
  @@map("user_roles")
}

// Unified language table for all translations (both HRL and LRL)
model Language {
  id           Int          @id @default(autoincrement())
  name         String       @unique // "English", "Yoruba", "Hausa"
  code         String       @unique // ISO 639-3: "eng", "yor", "hau"
  short        String? // Short name or abbreviation
  type         LanguageType // HRL or LRL
  description  String?
  icon         String?
  is_supported Boolean      @default(true)
  metadata     Json? // For LRL community info

  // Relations
  sourceTerms    Term[]               @relation("SourceLanguage")
  targetTerms    Term[]               @relation("TargetLanguage")
  sourceRequests TranslationRequest[] @relation("SourceLanguageRequest")
  targetRequests TranslationRequest[] @relation("TargetLanguageRequest")
  userLanguages  UserTargetLanguage[]
  quizQuestions  QuizQuestion[]

  @@map("languages")
}

enum LanguageType {
  HRL // High-Resource Language
  LRL // Low-Resource Language
}

model PartOfSpeech {
  id       Int                  @id @default(autoincrement())
  name     String               @unique // e.g. Noun
  code     String               @unique // e.g. N
  terms    Term[]
  requests TranslationRequest[]

  @@map("part_of_speech")
}

model Concept {
  id        Int      @id @default(autoincrement())
  gloss     String? // Universal explanation of the concept
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  terms       Term[]
  definitions Definition[]

  @@map("concepts")
}

model Term {
  id   Int    @id @default(autoincrement())
  text String

  // Source language (e.g., English word "Peace")
  sourceLanguageId Int
  sourceLanguage   Language @relation("SourceLanguage", fields: [sourceLanguageId], references: [id])

  // Target language (e.g., Yoruba translation "Alafia")
  targetLanguageId Int
  targetLanguage   Language @relation("TargetLanguage", fields: [targetLanguageId], references: [id])

  partOfSpeechId Int
  partOfSpeech   PartOfSpeech @relation(fields: [partOfSpeechId], references: [id])

  conceptId Int
  concept   Concept @relation(fields: [conceptId], references: [id])

  neos           Neo[]
  votes     Vote[]
  voteScore Int    @default(0) // Cached score for sorting

  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  @@map("terms")
}

model Definition {
  id   Int    @id @default(autoincrement())
  text String

  conceptId Int
  concept   Concept @relation(fields: [conceptId], references: [id])

  @@map("definitions")
}

model Vote {
  id        Int         @id @default(autoincrement())
  value     Int         // 1 for upvote, -1 for downvote
  
  userId    String      @db.Uuid
  user      UserProfile @relation(fields: [userId], references: [userId])
  
  termId    Int
  term      Term        @relation(fields: [termId], references: [id])

  neoId     Int
  neo       Neo         @relation(fields: [neoId], references: [id])
  
  createdAt DateTime    @default(now())

  @@unique([userId, termId])
  @@map("votes")
}

model Domain {
  id       Int                 @id @default(autoincrement())
  name     String              @unique
  requests DomainsOnRequests[]

  @@map("domains")
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model TranslationRequest {
  id      Int     @id @default(autoincrement())
  word    String
  meaning String? // Context provided by user

  // Source language (what language is the word in)
  sourceLanguageId Int
  sourceLanguage   Language @relation("SourceLanguageRequest", fields: [sourceLanguageId], references: [id])

  // Target language (what language to translate TO)
  targetLanguageId Int
  targetLanguage   Language @relation("TargetLanguageRequest", fields: [targetLanguageId], references: [id])

  partOfSpeechId Int
  partOfSpeech   PartOfSpeech @relation(fields: [partOfSpeechId], references: [id])

  userId String      @db.Uuid
  user   UserProfile @relation("RequestedBy", fields: [userId], references: [userId])

  domains DomainsOnRequests[]

  // Approval System
  status          RequestStatus @default(PENDING)
  approvedById    String?       @db.Uuid
  approvedBy      UserProfile?  @relation("ApprovedBy", fields: [approvedById], references: [userId])
  rejectionReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("translation_requests")
}

model DomainsOnRequests {
  requestId Int
  request   TranslationRequest @relation(fields: [requestId], references: [id])

  domainId Int
  domain   Domain @relation(fields: [domainId], references: [id])

  @@id([requestId, domainId])
  @@map("domains_on_requests")
}

// Join table for users joining LRL language communities
model UserTargetLanguage {
  id         Int    @id @default(autoincrement())
  userId     String @db.Uuid
  languageId Int

  user     UserProfile @relation(fields: [userId], references: [userId], onDelete: Cascade)
  language Language    @relation(fields: [languageId], references: [id], onDelete: Cascade)

  @@unique([userId, languageId])
  @@map("user_target_languages")
}

// Audit log for tracking sensitive operations
model AuditLog {
  id         Int      @id @default(autoincrement())
  userId     String   @db.Uuid
  action     String // e.g., "review:request:approved", "ai:analyze:request"
  resourceId String? // ID of the affected resource
  metadata   Json? // Additional context (reason, old values, etc.)
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// ─── Quiz System Models ──────────────────────────────────────────────────────

model QuizQuestion {
  id Int @id @default(autoincrement())

  // The language this question belongs to (e.g., Hausa, Yoruba)
  languageId Int
  language   Language @relation(fields: [languageId], references: [id], onDelete: Cascade)

  text          String
  options       Json // e.g., [{"label": "A", "value": "Option 1"}]
  correctAnswer String // Must match the "value" of one of the options directly

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("quiz_questions")
}

model QuizAttempt {
  id     Int         @id @default(autoincrement())
  userId String      @db.Uuid
  user   UserProfile @relation(fields: [userId], references: [userId], onDelete: Cascade)

  score  Int
  passed Boolean

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@map("quiz_attempts")
}

enum NeoType {
  POPULAR
  ADOPTIVE
  FUNCTIONAL
  ROOT
  CREATIVE
}

model Neo {
  id        Int         @id @default(autoincrement())
  text      String
  type      NeoType @default(POPULAR)
  audioUrl  String?
  userId    String      @db.Uuid
  user      UserProfile @relation(fields: [userId], references: [userId])
  
  termId    Int
  term      Term        @relation(fields: [termId], references: [id])
  ratingCount Int       @default(0)
  ratingScore  Int       @default(0)
  rejectCount Int       @default(0)

  votes       Vote[]
  neoRatings  NeoRating[]
  
  createdAt DateTime    @default(now())

  @@map("neos")
}


model NeoRating {
  id        Int         @id @default(autoincrement())
  value     Int         
  
  userId    String      @db.Uuid

  neoId     Int
  neo       Neo         @relation(fields: [neoId], references: [id])
  ratedBy   UserProfile? @relation("RatedBy", fields: [userId], references: [userId])
  rejectionReason  String?
  
  createdAt DateTime    @default(now())

  @@unique([userId, neoId])
  @@map("neo_rating")
}
